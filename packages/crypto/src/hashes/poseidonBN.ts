import { BN254ScalarField as F } from "../bnScalarField";
import { assert } from "../utils";

// Parameters are generated by a reference script https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/generate_parameters_grain.sage
// Used like so: sage generate_parameters_grain.sage 1 0 254 2 8 56 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001
import Params1 from "./constants/constants1";
import Params2 from "./constants/constants2";
import Params3 from "./constants/constants3";
import Params4 from "./constants/constants4";
import Params5 from "./constants/constants5";
import Params6 from "./constants/constants6";
import Params7 from "./constants/constants7";
import Params8 from "./constants/constants8";
import Params9 from "./constants/constants9";
import Params10 from "./constants/constants10";
import Params11 from "./constants/constants11";
import Params12 from "./constants/constants12";
import Params13 from "./constants/constants13";
import Params14 from "./constants/constants14";
import Params15 from "./constants/constants15";
import Params16 from "./constants/constants16";

type PoseidonParams = {
  C: bigint[];
  S: bigint[];
  M: bigint[][];
  P: bigint[][];
};

// Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
// Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
// And rounded up to nearest integer that divides by t
const N_ROUNDS_F = 8;
const N_ROUNDS_P = [
  56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68,
];

const pow5 = (a: bigint) => F.mul(a, F.sqr(F.sqr(a)));

export function poseidon1(inputs: [bigint], initialState?: bigint): bigint {
  return poseidonInner(inputs, initialState ?? F.ZERO, Params1);
}

export function poseidon2(
  inputs: [bigint, bigint],
  initialState?: bigint
): bigint {
  return poseidonInner(inputs, initialState ?? F.ZERO, Params2);
}

export function poseidon3(
  inputs: [bigint, bigint, bigint],
  initialState?: bigint
): bigint {
  return poseidonInner(inputs, initialState ?? F.ZERO, Params3);
}

export function poseidon4(
  inputs: [bigint, bigint, bigint, bigint],
  initialState?: bigint
): bigint {
  return poseidonInner(inputs, initialState ?? F.ZERO, Params4);
}

export function poseidon5(
  inputs: [bigint, bigint, bigint, bigint, bigint],
  initialState?: bigint
): bigint {
  return poseidonInner(inputs, initialState ?? F.ZERO, Params5);
}

export function poseidon6(
  inputs: [bigint, bigint, bigint, bigint, bigint, bigint],
  initialState?: bigint
): bigint {
  return poseidonInner(inputs, initialState ?? F.ZERO, Params6);
}

export function poseidon7(
  inputs: [bigint, bigint, bigint, bigint, bigint, bigint, bigint],
  initialState?: bigint
): bigint {
  return poseidonInner(inputs, initialState ?? F.ZERO, Params7);
}

export function poseidon8(
  inputs: [bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint],
  initialState?: bigint
): bigint {
  return poseidonInner(inputs, initialState ?? F.ZERO, Params8);
}

export function poseidon9(
  inputs: [
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint
  ],
  initialState?: bigint
): bigint {
  return poseidonInner(inputs, initialState ?? F.ZERO, Params9);
}

export function poseidon10(
  inputs: [
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint
  ],
  initialState?: bigint
): bigint {
  return poseidonInner(inputs, initialState ?? F.ZERO, Params10);
}

export function poseidon11(
  inputs: [
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint
  ],
  initialState?: bigint
): bigint {
  return poseidonInner(inputs, initialState ?? F.ZERO, Params11);
}

export function poseidon12(
  inputs: [
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint
  ],
  initialState?: bigint
): bigint {
  return poseidonInner(inputs, initialState ?? F.ZERO, Params12);
}

export function poseidon13(
  inputs: [
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint
  ],
  initialState?: bigint
): bigint {
  return poseidonInner(inputs, initialState ?? F.ZERO, Params13);
}

export function poseidon14(
  inputs: [
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint
  ],
  initialState?: bigint
): bigint {
  return poseidonInner(inputs, initialState ?? F.ZERO, Params14);
}

export function poseidon15(
  inputs: [
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint
  ],
  initialState?: bigint
): bigint {
  return poseidonInner(inputs, initialState ?? F.ZERO, Params15);
}

export function poseidon16(
  inputs: [
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint,
    bigint
  ],
  initialState?: bigint
): bigint {
  return poseidonInner(inputs, initialState ?? F.ZERO, Params16);
}

function poseidonInner(
  inputs: bigint[],
  initialState: bigint,
  { C, S, M, P }: PoseidonParams
): bigint {
  assert(inputs.length > 0);
  assert(inputs.length <= N_ROUNDS_P.length);

  const t = inputs.length + 1;
  const nRoundsF = N_ROUNDS_F;
  const nRoundsP = N_ROUNDS_P[t - 2];
  const zero = F.ZERO;

  let state = [initialState, ...inputs];

  state = state.map((a, i) => F.add(a, C[i]));

  for (let r = 0; r < nRoundsF / 2 - 1; r++) {
    state = state.map((a) => pow5(a));
    state = state.map((a, i) => F.add(a, C[(r + 1) * t + i]));
    state = state.map((_, i) =>
      state.reduce((acc, a, j) => F.add(acc, F.mul(M[j][i], a)), zero)
    );
  }
  state = state.map((a) => pow5(a));
  state = state.map((a, i) => F.add(a, C[(nRoundsF / 2 - 1 + 1) * t + i]));
  state = state.map((_, i) =>
    state.reduce((acc, a, j) => F.add(acc, F.mul(P[j][i], a)), F.ZERO)
  );
  for (let r = 0; r < nRoundsP; r++) {
    state[0] = pow5(state[0]);
    state[0] = F.add(state[0], C[(nRoundsF / 2 + 1) * t + r]);

    const s0 = state.reduce((acc, a, j) => {
      return F.add(acc, F.mul(S[(t * 2 - 1) * r + j], a));
    }, zero);
    for (let k = 1; k < t; k++) {
      state[k] = F.add(
        state[k],
        F.mul(state[0], S[(t * 2 - 1) * r + t + k - 1])
      );
    }
    state[0] = s0;
  }
  for (let r = 0; r < nRoundsF / 2 - 1; r++) {
    state = state.map((a) => pow5(a));
    state = state.map((a, i) =>
      F.add(a, C[(nRoundsF / 2 + 1) * t + nRoundsP + r * t + i])
    );
    state = state.map((_, i) =>
      state.reduce((acc, a, j) => F.add(acc, F.mul(M[j][i], a)), zero)
    );
  }
  state = state.map((a) => pow5(a));
  state = state.map((_, i) =>
    state.reduce((acc, a, j) => F.add(acc, F.mul(M[j][i], a)), zero)
  );

  return F.create(state[0]);
}
