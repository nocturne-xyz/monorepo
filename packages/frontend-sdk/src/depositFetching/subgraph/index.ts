import { FetchDepositRequestQuery, FetchDepositRequestsQuery,
  DepositRequestStatus as GqlDepositRequestStatus,
  DepositRequest as GqlDepositRequest,
} from "./gql/autogenerated/graphql";
import { DepositRequestsBySpenderQueryDocument } from "./gql/queries/DepositRequestsBySpenderQueryDocument";
import { DepositRequestStatusByHashQueryDocument } from "./gql/queries/DepositRequestStatusByHashQueryDocument";
import { DepositHandle, DepositRequestStatusWithMetadata, DisplayDepositRequestWithMetadataAndStatus, OnChainDepositRequestStatus } from "../../types";
import { OperationResult, Client as UrqlClient, fetchExchange } from "@urql/core";
import { flattenDepositRequestStatus, toDepositRequest } from "../../utils";
import { Address, AssetTrait, DepositStatusResponse, TotalEntityIndexTrait, hashDepositRequest } from "@nocturne-xyz/core";
import retry from "async-retry";
import { BigNumber } from "ethers";
import { DepositAdapter } from "../depositAdapter";

export class SubgraphDepositAdapter implements DepositAdapter {
  urqlClient: UrqlClient;
  screenerEndpoint: string;

  constructor(
    subgraphEndpoint: string,
    screenerEndpoint: string,
  ) {
    this.urqlClient = new UrqlClient({
      url: subgraphEndpoint,
      exchanges: [fetchExchange],
    });
    this.screenerEndpoint = screenerEndpoint;
  }


  async fetchDepositRequestsBySpender(spender: Address): Promise<DepositHandle[]> {
    const { data, error }: OperationResult<FetchDepositRequestsQuery> =
      await this.urqlClient.query(DepositRequestsBySpenderQueryDocument, {
        spender,
      });

    if (error || !data) {
      throw new Error(error?.message ?? "Deposit request query failed");
    }

    return Promise.all(
      data.depositRequests.map(toDepositRequestWithMetadata)
      .map(async (req) => this.makeDepositHandle(req))
    );
  }


  async makeDepositHandle(
    requestWithOnChainStatus: DisplayDepositRequestWithMetadataAndStatus
  ): Promise<DepositHandle> {
    const { onChainStatus, ...request } = requestWithOnChainStatus;
    const depositRequestHash = hashDepositRequest(toDepositRequest(request));
    const getStatus = async () =>
      await getDepositRequestStatus(
        this.screenerEndpoint,
        this.urqlClient,
        depositRequestHash
      );
    const currentStatus = await getDepositRequestStatus(
      this.screenerEndpoint,
      this.urqlClient,
      depositRequestHash,
      // the two types are identical
      onChainStatus ? onChainStatusToGqlStatus(onChainStatus) : undefined
    );
    return {
      depositRequestHash,
      request,
      currentStatus,
      getStatus,
    };
  }
}

async function getDepositRequestStatus(
  screenerEndpoint: string,
  urqlClient: UrqlClient,
  depositRequestHash: string,
  initialSubgraphStatus?: GqlDepositRequestStatus
): Promise<DepositRequestStatusWithMetadata> {
  let subgraphStatus = initialSubgraphStatus;
  if (!subgraphStatus) {
    const { data, error }: OperationResult<FetchDepositRequestQuery> =
      await urqlClient.query(DepositRequestStatusByHashQueryDocument, {
        hash: depositRequestHash,
      });
    if (error || !data) {
      throw new Error(error?.message ?? "Deposit request query failed");
    }
    if (!data.depositRequest) {
      throw new Error(
        `Deposit request with hash ${depositRequestHash} not found`
      );
    }
    subgraphStatus = data.depositRequest.status;
  }

  const screenerResponse = await retry(
    async () => {
      const res = await fetch(
        `${screenerEndpoint}/status/${depositRequestHash}`
      );
      return (await res.json()) as DepositStatusResponse;
    },
    {
      retries: 5,
    }
  );
  const { status: screenerStatus, estimatedWaitSeconds } = screenerResponse;
  const status = flattenDepositRequestStatus(
    // types are identical
    gqlStatusToOnChainStatus(subgraphStatus),
    screenerStatus
  );
  return {
    status,
    estimatedWaitSeconds,
  };
}

export function toDepositRequestWithMetadata(
  gqlDeposit: Omit<GqlDepositRequest, "id">
): DisplayDepositRequestWithMetadataAndStatus {
  const {
    spender,
    status,
    value,
    nonce,
    gasCompensation,
    encodedAssetAddr,
    encodedAssetId,
    depositAddrH1,
    depositAddrH2,
    instantiationTxHash,
    completionTxHash,
    retrievalTxHash,
  } = gqlDeposit;
  const asset = AssetTrait.decode({
    encodedAssetAddr: BigInt(encodedAssetAddr),
    encodedAssetId: BigInt(encodedAssetId),
  });
  return {
    spender,
    // types are identical
    onChainStatus: gqlStatusToOnChainStatus(status),
    value: BigNumber.from(value),
    nonce: BigNumber.from(nonce),
    gasCompensation: BigNumber.from(gasCompensation),
    asset: {
      ...asset,
      id: BigNumber.from(asset.id),
    },
    depositAddr: {
      h1: BigNumber.from(depositAddrH1),
      h2: BigNumber.from(depositAddrH2),
    },
    createdAtBlock: TotalEntityIndexTrait.convertToBlockNumber(
      BigInt(gqlDeposit.createdAtTotalEntityIndex)
    ),
    txHashInstantiated: instantiationTxHash,
    txHashCompleted: completionTxHash,
    txHashRetrieved: retrievalTxHash,
  };
}

function gqlStatusToOnChainStatus(
  gqlStatus: GqlDepositRequestStatus
): OnChainDepositRequestStatus {
  switch (gqlStatus) {
    case GqlDepositRequestStatus.Retrieved:
      return OnChainDepositRequestStatus.Retrieved;
    case GqlDepositRequestStatus.Completed:
      return OnChainDepositRequestStatus.Completed;
    case GqlDepositRequestStatus.Pending:
      return OnChainDepositRequestStatus.Pending;
    default:
      throw new Error(`Unknown status: ${gqlStatus}`);
  }
}

function onChainStatusToGqlStatus(
  onChainStatus: OnChainDepositRequestStatus
): GqlDepositRequestStatus {
  switch (onChainStatus) {
    case OnChainDepositRequestStatus.Retrieved:
      return GqlDepositRequestStatus.Retrieved;
    case OnChainDepositRequestStatus.Completed:
      return GqlDepositRequestStatus.Completed;
    case OnChainDepositRequestStatus.Pending:
      return GqlDepositRequestStatus.Pending;
    default:
      throw new Error(`Unknown status: ${onChainStatus}`);
  }
}