import { DepositHandle, DepositRequestStatusWithMetadata, DisplayDepositRequestWithMetadataAndStatus, OnChainDepositRequestStatus, parseOnChainDepositRequestStatus } from "../../types";
import { DepositAdapter } from "../depositAdapter";
import { ArrayElem, DepositStatusResponse, hashDepositRequest } from "@nocturne-xyz/core";
import { Client as UrqlClient, fetchExchange } from "@urql/core";
import { Address } from "@nocturne-xyz/core";
import { flattenDepositRequestStatus, toDepositRequest } from "../../utils";
import retry from "async-retry";
import { hexToBytea, depositRequestResponseToDepositRequestWithMetadata } from "./fetch";
import { GoerliDepositRequestStatusById, GoerliDepositRequestsBySpender, MainnetDepositRequestStatusById, MainnetDepositRequestsBySpender } from "./gql/queries";
import { GoerliFetchDepositRequestsQuery } from "./gql/autogenerated/graphql";

type HasuraSupportedNetwork = "mainnet" | "goerli";
const HasuraSupportedNetworks = [
  "mainnet",
  "goerli",
];

const GoerliQueries = {
  DepositRequestsBySpender: GoerliDepositRequestsBySpender,
  DepositRequestStatusById: GoerliDepositRequestStatusById,
};

const MainnetQueries = {
  DepositRequestsBySpender: MainnetDepositRequestsBySpender,
  DepositRequestStatusById: MainnetDepositRequestStatusById,
};

const QueriesByNetwork = {
  mainnet: MainnetQueries,
  goerli: GoerliQueries,
};

type DepositRequestResponse = ArrayElem<GoerliFetchDepositRequestsQuery["goerli_deposit_requests"]>;

export class HasuraDepositAdapter implements DepositAdapter {
  client: UrqlClient;
  screenerEndpoint: string;
  network: HasuraSupportedNetwork;

  constructor(graphqlEndpoint: string, screenerEndpoint: string, network: string) {
    this.client = new UrqlClient({
      url: graphqlEndpoint,
      exchanges: [fetchExchange],
    });
    this.screenerEndpoint = screenerEndpoint;

    if (!HasuraSupportedNetworks.includes(network)) {
      throw new Error(
        `HasuraDepositAdapter doesn't support network: ${network}`
      );
    }

    this.network = network as HasuraSupportedNetwork;
  }
  
  async fetchDepositRequestsBySpender(spender: Address): Promise<DepositHandle[]> {
    const spenderBytea = hexToBytea(spender);
    const { DepositRequestsBySpender } = QueriesByNetwork[this.network];
    const { data, error } = await this.client.query(DepositRequestsBySpender, { spender: spenderBytea });
    if (error || !data) {
      throw new Error(error?.message ?? "Deposit request query failed");
    }

    //@ts-ignore
    const depositRequestResponses = data[`${network}_deposit_requests`] as DepositRequestResponse[];

    return Promise.all(
      depositRequestResponses.map((res) => depositRequestResponseToDepositRequestWithMetadata(spender, res))
      .map((depositRequest) => this.makeDepositHandle(depositRequest))
    );
  }

  async makeDepositHandle(requestWithOnChainStatus: DisplayDepositRequestWithMetadataAndStatus): Promise<DepositHandle> {
    const { onChainStatus, ...request } = requestWithOnChainStatus;
    const hash = hashDepositRequest(toDepositRequest(request));

    const getStatus = async () => getDepositRequestStatus(
      this.network,
      this.screenerEndpoint,
      this.client,
      hash,
      onChainStatus
    );

    return {
      depositRequestHash: hash,
      request,
      currentStatus: await getStatus(),
      getStatus,
    };    
  }
}

async function getDepositRequestStatus(
  network: SupportedNetwork,
  screenerEndpoint: string,
  client: UrqlClient,
  depositRequestHash: string,
  initialOnChainStatus?: OnChainDepositRequestStatus 
): Promise<DepositRequestStatusWithMetadata> {
  const { DepositRequestStatusById } = QueriesByNetwork[network];

  if (!initialOnChainStatus) {
    const { data, error } = await client.query(DepositRequestStatusById, { hash: depositRequestHash });
    if (error || !data) {
      throw new Error(error?.message ?? "Deposit request query failed");
    }

    if (data.deposit_request.length === 0) {
      throw new Error("Deposit request not found");
    }
    initialOnChainStatus= parseOnChainDepositRequestStatus(data.deposit_request[0].status);
  }

  const screenerResponse = await retry(
    async () => {
      const res = await fetch(
        `${screenerEndpoint}/status/${depositRequestHash}`
      );
      return (await res.json()) as DepositStatusResponse;
    },
    {
      retries: 5,
    }
  );
  const { status: screenerStatus, estimatedWaitSeconds } = screenerResponse;

  const status = flattenDepositRequestStatus(
    initialOnChainStatus,
    screenerStatus
  );

  return {
    status,
    estimatedWaitSeconds,
  };
}
;