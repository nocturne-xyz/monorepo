import { DepositHandle, DepositRequestStatusWithMetadata, DisplayDepositRequestWithMetadataAndStatus, OnChainDepositRequestStatus, parseOnChainDepositRequestStatus } from "../../types";
import { DepositAdapter } from "../depositAdapter";
import { ArrayElemType, DepositStatusResponse, TotalEntityIndexTrait, hashDepositRequest } from "@nocturne-xyz/core";
import { Client as UrqlClient, fetchExchange } from "@urql/core";
import { FetchDepositRequestsQuery, FetchDepositStatusQuery } from "./gql/autogenerated/graphql";
import { DepositRequestStatusById, DepositRequestsBySpender } from "./gql/queries";
import { Address, AssetTrait } from "@nocturne-xyz/core";
import { BigNumber } from "ethers";
import { flattenDepositRequestStatus, toDepositRequest } from "../../utils";
import retry from "async-retry";

export class HasuraDepositAdapter implements DepositAdapter {
  client: UrqlClient;
  screenerEndpoint: string;

  constructor(graphqlEndpoint: string, screenerEndpoint: string) {
    this.client = new UrqlClient({
      url: graphqlEndpoint,
      exchanges: [fetchExchange],
    });
    this.screenerEndpoint = screenerEndpoint;
  }
  
  async fetchDepositRequestsBySpender(spender: Address): Promise<DepositHandle[]> {
    spender = addressToBytea(spender);
    const { data, error } = await this.client.query<FetchDepositRequestsQuery>(DepositRequestsBySpender, { spender });
    if (error || !data) {
      throw new Error(error?.message ?? "Deposit request query failed");
    }

    return Promise.all(
      data.goerli_goerli_deposit_request.map((res) => depositRequestResponseToDepositRequestWithMetadata(spender, res))
      .map((depositRequest) => this.makeDepositHandle(depositRequest))
    );
  }

  async makeDepositHandle(requestWithOnChainStatus: DisplayDepositRequestWithMetadataAndStatus): Promise<DepositHandle> {
    const { onChainStatus: onChainStatusStr, ...request } = requestWithOnChainStatus;
    const onChainStatus = onChainStatusStr ? parseOnChainDepositRequestStatus(onChainStatusStr) : undefined; 
    const hash = hashDepositRequest(toDepositRequest(request));

    const getStatus = async () => getDepositRequestStatus(
      this.screenerEndpoint,
      this.client,
      hash,
      onChainStatus
    );

    const currentStatus = await getDepositRequestStatus(
      this.screenerEndpoint,
      this.client,
      hash,
      onChainStatus
    );

    return {
      depositRequestHash: hash,
      request,
      currentStatus,
      getStatus,
    };     
  }
}

async function getDepositRequestStatus(
  screenerEndpoint: string,
  client: UrqlClient,
  depositRequestHash: string,
  initialOnChainStatus?: OnChainDepositRequestStatus 
): Promise<DepositRequestStatusWithMetadata> {
  if (!initialOnChainStatus) {
    const { data, error } = await client.query<FetchDepositStatusQuery>(DepositRequestStatusById, { hash: depositRequestHash });
    if (error || !data) {
      throw new Error(error?.message ?? "Deposit request query failed");
    }

    if (data.goerli_goerli_deposit_request.length === 0) {
      throw new Error("Deposit request not found");
    }
    initialOnChainStatus= parseOnChainDepositRequestStatus(data.goerli_goerli_deposit_request[0].status);
  }

  const screenerResponse = await retry(
    async () => {
      const res = await fetch(
        `${screenerEndpoint}/status/${depositRequestHash}`
      );
      return (await res.json()) as DepositStatusResponse;
    },
    {
      retries: 5,
    }
  );
  const { status: screenerStatus, estimatedWaitSeconds } = screenerResponse;

  const status = flattenDepositRequestStatus(
    initialOnChainStatus,
    screenerStatus
  );

  return {
    status,
    estimatedWaitSeconds,
  };
}

function depositRequestResponseToDepositRequestWithMetadata(spender: Address, depositRequestResponse: ArrayElemType<FetchDepositRequestsQuery["goerli_goerli_deposit_request"]>): DisplayDepositRequestWithMetadataAndStatus {
  const asset = AssetTrait.decode({
    encodedAssetAddr: BigInt(depositRequestResponse.encoded_asset_addr as string),
    encodedAssetId: BigInt(depositRequestResponse.encoded_asset_id as string),
  });

  return {
    spender: spender,
    asset: {
      ...asset,
      id: BigNumber.from(asset.id),
    },
    value: BigNumber.from(depositRequestResponse.value),
    depositAddr: {
      h1: BigNumber.from(depositRequestResponse.deposit_addr_h1),
      h2: BigNumber.from(depositRequestResponse.deposit_addr_h2),
    },
    nonce: BigNumber.from(depositRequestResponse.nonce),
    gasCompensation: BigNumber.from(depositRequestResponse.gas_compensation),
    txHashInstantiated: hexStringFromBytea(depositRequestResponse.instantiation_tx_hash as string),
    txHashCompleted: hexStringFromBytea(depositRequestResponse.completion_tx_hash as string),
    txHashRetrieved: hexStringFromBytea(depositRequestResponse.retrieval_tx_hash),
    createdAtBlock: TotalEntityIndexTrait.convertToBlockNumber(BigInt(depositRequestResponse.created_at_total_entity_index as string)),
    onChainStatus: depositRequestResponse.status ? parseOnChainDepositRequestStatus(depositRequestResponse.status) : undefined,
  };
}

function addressToBytea(address: Address): string {
  // convert to lowercase
  address = address.toLowerCase();
  return "\\x" + address.slice(2);
}

function hexStringFromBytea(bytea: string): Address {
  return "0x" + bytea.slice(2);
}

