import { AssetTrait, IncludedEncryptedNote, IncludedNote, Nullifier, StealthAddressTrait, TotalEntityIndex, TotalEntityIndexTrait, WithTotalEntityIndex, batchOffsetToLatestMerkleIndexInBatch, ArrayElemType, Address } from "@nocturne-xyz/core";
import { Client as UrqlClient } from "@urql/core";
import { SdkEventsPaginatedById } from "./gql/queries";
import { FetchDepositRequestsQuery, FetchSdkEventsQuery } from "./gql/autogenerated/graphql";
import { BigNumber, ethers } from "ethers";
import { DisplayDepositRequestWithMetadataAndStatus, parseOnChainDepositRequestStatus } from "../../types";

type SdkEvent =
  | IncludedNote
  | IncludedEncryptedNote
  | Nullifier
  | FilledBatchWithZerosEndMerkleIndex;
type FilledBatchWithZerosEndMerkleIndex = number;
type SdkEventsWithLatestCommittedMerkleIndex = { events: WithTotalEntityIndex<SdkEvent>[], latestCommittedMerkleIndex?: number };
type SdkEventResponse = ArrayElemType<FetchSdkEventsQuery['goerli_goerli_sdk_event']>

export async function fetchSdkEventsAndLatestCommittedMerkleIndex(
  client: UrqlClient,
  from: TotalEntityIndex,
  toBlock: number,
  limit  = 1000
): Promise<SdkEventsWithLatestCommittedMerkleIndex> {
  const { data, error } = await client.query(SdkEventsPaginatedById, { from: TotalEntityIndexTrait.toStringPadded(from), toBlock, limit });

  if (error || !data) {
    throw new Error(error?.message ?? "SdkEvents query failed");
  }

  const events: WithTotalEntityIndex<SdkEvent>[] = data.goerli_goerli_sdk_event.map(res => {
    const totalEntityIndex = BigInt(res.id);
    const event = tryIncludedEncryptedNoteFromSdkEventResponse(res) ?? tryIncludedNoteFromSdkEventResponse(res) ?? tryNullifierFromSdkEventResponse(res) ?? tryFilledBatchWithZerosEndMerkleIndexFromSdkEventResponse(res);

    if (!event) {
      throw new Error("Invalid SdkEvent response");
    }

    return {
      totalEntityIndex,
      inner: event,
    };
  });

  let latestCommittedMerkleIndex: number | undefined = undefined;
  if (data.goerli_goerli_subtree_commit && data.goerli_goerli_subtree_commit.length > 0) {
    const subtreeCommit = data.goerli_goerli_subtree_commit[0];
    const batchOffset = parseInt(subtreeCommit.subtree_batch_offset);
    latestCommittedMerkleIndex = batchOffsetToLatestMerkleIndexInBatch(batchOffset);
  }

  return {
    events,
    latestCommittedMerkleIndex,
  };
}

function tryIncludedNoteFromSdkEventResponse(res: SdkEventResponse): IncludedNote | undefined {
  if (
    res &&
    res.merkle_index &&
    res.encoded_note_encoded_asset_addr &&
    res.encoded_note_encoded_asset_id &&
    res.encoded_note_owner_h1 &&
    res.encoded_note_owner_h2 &&
    res.encoded_note_value &&
    res.encoded_note_nonce &&
    !res.encrypted_note_ciphertext_bytes &&
    !res.encrypted_note_commitment &&
    !res.encrypted_note_encapsulated_secret_bytes && 
    !res.nullifier
  ) {
    return {
      owner: StealthAddressTrait.decompress({
        h1: BigInt(res.encoded_note_owner_h1 as string),
        h2: BigInt(res.encoded_note_owner_h2 as string),
      }),
      asset: AssetTrait.decode({
        encodedAssetAddr: BigInt(res.encoded_note_encoded_asset_addr as string),
        encodedAssetId: BigInt(res.encoded_note_encoded_asset_id as string),
      }),
      value: BigInt(res.encoded_note_value as string),
      nonce: BigInt(res.encoded_note_nonce as string),
      merkleIndex: parseInt(res.merkle_index as string),
    };
  }

  return undefined;
}

function tryIncludedEncryptedNoteFromSdkEventResponse(res: SdkEventResponse): IncludedEncryptedNote | undefined {
  if (
    res &&
    res.merkle_index &&
    res.encrypted_note_ciphertext_bytes &&
    res.encrypted_note_commitment &&
    res.encrypted_note_encapsulated_secret_bytes &&
    !res.encoded_note_encoded_asset_addr &&
    !res.encoded_note_encoded_asset_id &&
    !res.encoded_note_owner_h1 &&
    !res.encoded_note_owner_h2 &&
    !res.encoded_note_value &&
    !res.encoded_note_nonce &&
    !res.nullifier
  ) {
    return {
      ciphertextBytes: Array.from(
        ethers.utils.arrayify(hexStringFromBytea(res.encrypted_note_ciphertext_bytes as string))
      ),
      encapsulatedSecretBytes: Array.from(
        ethers.utils.arrayify(hexStringFromBytea(res.encrypted_note_encapsulated_secret_bytes as string))
      ),
      commitment: BigInt(res.encrypted_note_commitment as string),
      merkleIndex: parseInt(res.merkle_index as string),
    };
  }

  return undefined;
}

function tryNullifierFromSdkEventResponse(res: SdkEventResponse): Nullifier | undefined {
  if (
    res &&
    res.nullifier &&
    !res.merkle_index &&
    !res.encrypted_note_ciphertext_bytes &&
    !res.encrypted_note_commitment &&
    !res.encrypted_note_encapsulated_secret_bytes &&
    !res.encoded_note_encoded_asset_addr &&
    !res.encoded_note_encoded_asset_id &&
    !res.encoded_note_owner_h1 &&
    !res.encoded_note_owner_h2 &&
    !res.encoded_note_value &&
    !res.encoded_note_nonce
  ) {
    return BigInt(res.nullifier as string);
  }

  return undefined;
}

function tryFilledBatchWithZerosEndMerkleIndexFromSdkEventResponse(res: SdkEventResponse): FilledBatchWithZerosEndMerkleIndex | undefined {
  if (
    res &&
    res.merkle_index &&
    !res.encrypted_note_ciphertext_bytes &&
    !res.encrypted_note_commitment &&
    !res.encrypted_note_encapsulated_secret_bytes &&
    !res.encoded_note_encoded_asset_addr &&
    !res.encoded_note_encoded_asset_id &&
    !res.encoded_note_owner_h1 &&
    !res.encoded_note_owner_h2 &&
    !res.encoded_note_value &&
    !res.encoded_note_nonce &&
    !res.nullifier
  ) {
    return parseInt(res.merkle_index as string);
  }

  return undefined;
}

export function depositRequestResponseToDepositRequestWithMetadata(spender: Address, depositRequestResponse: ArrayElemType<FetchDepositRequestsQuery["goerli_goerli_deposit_request"]>): DisplayDepositRequestWithMetadataAndStatus {
  const {
    encoded_asset_addr,
    encoded_asset_id,
    value,
    nonce,
    status,
    deposit_addr_h1,
    deposit_addr_h2,
    gas_compensation,
    instantiation_tx_hash,
    completion_tx_hash,
    retrieval_tx_hash,
    created_at_total_entity_index,
  } = depositRequestResponse;

  const asset = AssetTrait.decode({
    encodedAssetAddr: BigInt(encoded_asset_addr as string),
    encodedAssetId: BigInt(encoded_asset_id as string),
  });

  return {
    spender: spender,
    asset: {
      ...asset,
      id: BigNumber.from(asset.id),
    },
    value: BigNumber.from(value),
    depositAddr: {
      h1: BigNumber.from(deposit_addr_h1),
      h2: BigNumber.from(deposit_addr_h2),
    },
    nonce: BigNumber.from(nonce),
    gasCompensation: BigNumber.from(gas_compensation),
    txHashInstantiated: instantiation_tx_hash ? hexStringFromBytea(instantiation_tx_hash as string) : undefined,
    txHashCompleted: completion_tx_hash ? hexStringFromBytea(completion_tx_hash as string) : undefined,
    txHashRetrieved: retrieval_tx_hash ? hexStringFromBytea(retrieval_tx_hash as string) : undefined,
    createdAtBlock: TotalEntityIndexTrait.convertToBlockNumber(BigInt(created_at_total_entity_index as string)),
    onChainStatus: status ? parseOnChainDepositRequestStatus(status) : undefined,
  };
}

export function hexToBytea(hex: string): string {
  // convert to lowercase
  hex = hex.toLowerCase();
  return "\\x" + hex.slice(2);
}

function hexStringFromBytea(bytea: string): Address {
  return "0x" + bytea.slice(2);
}

