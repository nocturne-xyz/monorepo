import { loadNocturneConfigBuiltin } from "@nocturne-xyz/config";
import {
  Address,
  AssetType,
  DepositRequestStatus as ScreenerDepositRequestStatus,
  TotalEntityIndexTrait,
} from "@nocturne-xyz/core";
import { ethers } from "ethers";
import ERC1155 from "./abis/ERC1155.json";
import ERC20 from "./abis/ERC20.json";
import ERC721 from "./abis/ERC721.json";
import {
  DepositRequest as GqlDepositRequest,
  DepositRequestStatus as GqlDepositRequestStatus,
} from "./gql/autogenerated/graphql";
import {
  DepositRequestStatus,
  DepositRequestWithMetadata,
  NocturneSdkConfig,
  SupportedNetwork,
  Endpoints,
  TokenDetails,
} from "./types";

const ENDPOINTS = {
  sepolia: {
    screenerEndpoint: "https://screener.nocturnelabs.xyz",
    bundlerEndpoint: "https://bundler.nocturnelabs.xyz",
    subgraphEndpoint: "https://api.goldsky.com/api/public/project_cldkt6zd6wci33swq4jkh6x2w/subgraphs/nocturne/0.1.21-testnet/gn",
  },
  localhost: {
    screenerEndpoint: "http://localhost:3001",
    bundlerEndpoint: "http://localhost:3000",
    subgraphEndpoint: "http://localhost:8000/subgraphs/name/nocturne",
  },
};

export function getTokenContract(
  assetType: AssetType,
  assetAddress: Address,
  signerOrProvider: ethers.Signer | ethers.providers.Provider
): ethers.Contract {
  let abi;
  if (assetType == AssetType.ERC20) {
    abi = ERC20;
  } else if (assetType == AssetType.ERC721) {
    abi = ERC721;
  } else if (assetType == AssetType.ERC1155) {
    abi = ERC1155;
  } else {
    throw new Error(`unknown asset type: ${assetType}`);
  }

  return new ethers.Contract(assetAddress, abi, signerOrProvider);
}

export async function getTokenDetails(
  assetType: AssetType,
  assetAddress: Address,
  signerOrProvider: ethers.Signer | ethers.providers.Provider
): Promise<TokenDetails> {
  console.log("getting token contract...");
  const tokenContract = getTokenContract(
    assetType,
    assetAddress,
    signerOrProvider
  );

  if (assetType == AssetType.ERC20) {
    const decimals = await tokenContract.decimals();
    const symbol = await tokenContract.symbol();
    return { decimals, symbol };
  } else if (assetType == AssetType.ERC721) {
    const symbol = await tokenContract.symbol();
    return { decimals: 1, symbol };
  } else if (assetType == AssetType.ERC1155) {
    return { decimals: 1, symbol: "" };
  } else {
    throw new Error(`unknown asset variant: ${assetType}`);
  }
}

export function formatTokenAmountUserRepr(
  balance: bigint,
  decimals: number
): number {
  return Number(balance) / Math.pow(10, decimals);
}

export function formatTokenAmountEvmRepr(
  amount: number,
  decimals: number
): bigint {
  return BigInt(amount * Math.pow(10, decimals));
}

export function formatAbbreviatedAddress(address: string): string {
  return (
    address.substring(0, 6) +
    "..." +
    address.substring(address.length - 4)
  ).toLowerCase();
}

export function getNocturneSdkConfig(
  networkName: SupportedNetwork
): NocturneSdkConfig {
  const config = loadNocturneConfigBuiltin(networkName);
  
  let endpoints: Endpoints;
  switch (networkName) {
    case "sepolia":
      endpoints = ENDPOINTS.sepolia;
      break;
    case "localhost":
      endpoints = ENDPOINTS.localhost;
      break;
    default:
      throw new Error(`Network not supported: ${networkName}`);
  }

  return {
    config,
    endpoints,
  };
};

// TODO add as method in core SDK
export function convertToBlockNumber(createdAtTotalEntityIndex: bigint): number {
  return Number(
    TotalEntityIndexTrait.toComponents(createdAtTotalEntityIndex).blockNumber
  );
};

export function toDepositRequestWithMetadata(
  gqlDeposit: Omit<GqlDepositRequest, "id">
): DepositRequestWithMetadata & {
  subgraphStatus: GqlDepositRequestStatus;
} {
  const {
    spender,
    status,
    value,
    nonce,
    gasCompensation,
    encodedAssetAddr,
    encodedAssetId,
    depositAddrH1,
    depositAddrH2,
    instantiationTxHash,
    completionTxHash,
    retrievalTxHash,
  } = gqlDeposit;
  return {
    spender,
    subgraphStatus: status,
    value,
    nonce,
    gasCompensation,
    encodedAsset: {
      encodedAssetAddr,
      encodedAssetId,
    },
    depositAddr: {
      h1: depositAddrH1,
      h2: depositAddrH2,
    },
    createdAtBlock: convertToBlockNumber(
      BigInt(gqlDeposit.createdAtTotalEntityIndex)
    ),
    txHashInstantiated: instantiationTxHash,
    txHashCompleted: completionTxHash,
    txHashRetrieved: retrievalTxHash,
  };
};


export function flattenDepositRequestStatus(
  subgraphStatus: GqlDepositRequestStatus,
  screenerStatus: ScreenerDepositRequestStatus,
): DepositRequestStatus {
  switch (subgraphStatus) {
    case GqlDepositRequestStatus.Retrieved:
      return DepositRequestStatus.Retrieved;
    case GqlDepositRequestStatus.Completed:
      // ! TODO need access to logic to distinguish between FULFILLED and COMPLETE. COMPLETE if new note is committed in tree, FULFILLED otherwise
      return DepositRequestStatus.Complete;
    case GqlDepositRequestStatus.Pending: {
      switch (screenerStatus) {
        case ScreenerDepositRequestStatus.FailedScreen:
          return DepositRequestStatus.FailedScreen;
        case ScreenerDepositRequestStatus.PassedFirstScreen:
        case ScreenerDepositRequestStatus.AwaitingFulfillment:
          return DepositRequestStatus.AwaitingFulfillment;
        default:
          return DepositRequestStatus.Initiated;
      }
    }
    default:
      return DepositRequestStatus.DoesNotExist;
  }
};