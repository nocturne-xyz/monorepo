// SPDX-License-Identifier: MIT
pragma solidity ^0.8.2;
pragma abicoder v2;

import "forge-std/Test.sol";
import "forge-std/StdJson.sol";
import "forge-std/console.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import {ParseUtils} from "../utils/ParseUtils.sol";
import "../harnesses/TestTellerBase.sol";
import "../../libs/Types.sol";

contract TellerBaseTest is Test {
    TestTellerBase public tellerBase;

    function testOperationHashMatchesOffchainImpl() public {
        // NOTE: reference sdk/scripts/generateOperationHashTestCase.ts for inputs/expected outputs
        tellerBase = new TestTellerBase();
        tellerBase.initialize("NocturneTeller", "v1");

        JoinSplitWithoutProof[] memory joinSplits = new JoinSplitWithoutProof[](
            1
        );
        joinSplits[0] = JoinSplitWithoutProof({
            commitmentTreeRoot: 1,
            nullifierA: 1,
            nullifierB: 1,
            newNoteACommitment: 1,
            newNoteBCommitment: 1,
            senderCommitment: 1,
            encodedAsset: EncodedAsset({
                encodedAssetAddr: 1,
                encodedAssetId: 1
            }),
            publicSpend: 1,
            newNoteAEncrypted: EncryptedNote({
                ciphertextBytes: bytes(""),
                encapsulatedSecretBytes: bytes("")
            }),
            newNoteBEncrypted: EncryptedNote({
                ciphertextBytes: bytes(""),
                encapsulatedSecretBytes: bytes("")
            })
        });

        Action[] memory actions = new Action[](1);
        actions[0] = Action({
            contractAddress: address(
                0x690B9A9E9aa1C9dB991C7721a92d351Db4FaC990
            ),
            encodedFunction: hex"1234"
        });

        EncodedAsset[] memory encodedRefundAssets = new EncodedAsset[](1);
        encodedRefundAssets[0] = EncodedAsset({
            encodedAssetAddr: 1,
            encodedAssetId: 1
        });

        OperationWithoutProof memory operation = OperationWithoutProof({
            joinSplits: joinSplits,
            refundAddr: CompressedStealthAddress({h1: 1, h2: 1}),
            encodedRefundAssets: encodedRefundAssets,
            actions: actions,
            encodedGasAsset: EncodedAsset({
                encodedAssetAddr: 1,
                encodedAssetId: 1
            }),
            gasAssetRefundThreshold: 1,
            executionGasLimit: 1,
            maxNumRefunds: 1,
            gasPrice: 1,
            chainId: 1,
            deadline: 1,
            atomicActions: true
        });

        bytes32 operationHash = tellerBase.hashOperation(operation);

        console.log("operationHash:");
        console.logBytes32(operationHash);
        console.log("");

        // Operation hash generated by running test case gen script in SDK
        assertEq(
            operationHash,
            bytes32(
                0xd6eedf68b4ebdf58b924b525780530f709588ed241b5b7c3531cc4cfecd4c5b1
            )
        );

        vm.chainId(123);
        vm.etch(
            address(0x1111111111111111111111111111111111111111),
            address(tellerBase).code
        );
        vm.store(
            address(0x1111111111111111111111111111111111111111),
            bytes32(uint256(1)),
            keccak256(bytes("NocturneTeller"))
        );
        vm.store(
            address(0x1111111111111111111111111111111111111111),
            bytes32(uint256(2)),
            keccak256(bytes("v1"))
        );

        bytes32 operationDigest = ITestTellerBase(
            address(0x1111111111111111111111111111111111111111)
        ).computeDigest(operation);

        console.log("operationDigest:");
        console.logBytes32(operationDigest);
        console.log("");

        // Operation digest generated by running test case gen script in SDK
        assertEq(
            operationDigest,
            bytes32(
                0x1c9c50814e1df7c0d9c53c65c05ac2232ed9025bdc9a732462b228a95bb721cf
            )
        );
    }
}
